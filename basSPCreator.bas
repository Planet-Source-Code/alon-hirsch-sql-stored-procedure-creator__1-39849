Attribute VB_Name = "basSPCreator"
Option Explicit
DefInt A-Z

Global g_objGlobal As clsGlobal
Private m_sComment As String
Private m_sOutputFile As String
Public Sub GenerateAllStoredProcs(acnCon As ADODB.Connection, lstTables As ListBox, _
                                    ByVal bInsert As Boolean, ByVal bUpdate As Boolean, _
                                    ByVal bDelete As Boolean, ByVal bSelect As Boolean, _
                                    ByVal bFields As Boolean, ByVal bIdentity As Boolean, _
                                    ByVal bSingle As Boolean, ByVal bOutput As Boolean, _
                                    ByVal bUpdateDB As Boolean, ByVal bDropSP As Boolean, _
                                    ByVal sOutPutFolder As String)
    ' this will loop through the listbox and generate the required stored procs
    ' for each of the selected items
    Dim sItem As String
    Dim sTable As String
    Dim sType As String
    Dim sScript As String
    Dim lItems As Long
    Dim lItem As Long
    Dim lTemp As Long
    Dim lScriptTotal As Long
    Dim lScript As Long
    Dim lTableTotal As Long
    Dim lTable As Long
    Dim iTablePercent As Integer
    Dim iScriptPercent As Integer
    
    Screen.MousePointer = vbHourglass
    
    ' define the SQL comment to go into each stored proc
    m_sComment = "/*" & vbCrLf
    m_sComment = m_sComment & vbTab & "Generated by '" & Trim$(g_objGlobal.sAppTitle) & "' version " & g_objGlobal.sVersion
    m_sComment = m_sComment & " , " & App.Comments & vbCrLf
    m_sComment = m_sComment & vbTab & "SQL Script Generated on " & Format$(Now, "dd/mm/yyyy") & vbCrLf
    m_sComment = m_sComment & "*/"
    
    ' determine how many tables have been selected
    lTableTotal = lstTables.SelCount
    
    ' determine how many scripts to generate for each table
    lScriptTotal = 0
    lScriptTotal = lScriptTotal + Abs(bInsert)
    lScriptTotal = lScriptTotal + Abs(bUpdate)
    lScriptTotal = lScriptTotal + Abs(bDelete)
    lScriptTotal = lScriptTotal + Abs(bSelect)
    lScriptTotal = lScriptTotal + Abs(bFields)
    lScriptTotal = lScriptTotal + Abs(bIdentity)
    lScriptTotal = lScriptTotal + Abs(bSingle)
    
    ' if we are not updating the DB - create a blank text file
    If Not bUpdateDB Then
        ' create a new output file
        m_sOutputFile = sOutPutFolder & "\StoredProcs_" & Format$(Now, "yyyymmddhhnnss") & ".txt"
        Open m_sOutputFile For Output As #1
        Close #1
    End If
        
    ' show the progress form
    With frmProgress
        .lblScript.Caption = ""
        .lblScriptFrom.Caption = ""
        .lblScriptPerc.Caption = "0 %"
        .lblScriptTotal = Format$(lScriptTotal, "###,##0")
        .lblTable.Caption = ""
        .lblTableFrom.Caption = ""
        .lblTablePerc = "0 %"
        .lblTableTotal = Format$(lTableTotal, "###,##0")
        .prgScripts.Value = 0
        .prgTables.Value = 0
        .Show vbModeless, frmSPCreator
        DoEvents
    End With
    
    ' prepare the loop
    lItems = lstTables.ListCount - 1
    lTable = 0
    For lItem = 0 To lItems
        ' check each of the tables in the list to see if they are selected
        If lstTables.Selected(lItem) Then
            ' it is selected - script it
            lTable = lTable + 1
            ' get the entry from the list
            sItem = lstTables.List(lItem)
            ' get the type
            lTemp = InStrRev(sItem, "(")
            sType = Mid$(sItem, lTemp + 1)
            sType = Trim$(Left$(sType, Len(sType) - 1))
            ' and the name
            sTable = Trim$(Left$(sItem, lTemp - 1))
            
            ' update the progress display to reflect the name and table number
            frmProgress.lblTable.Caption = sTable
            frmProgress.lblTableFrom.Caption = Format$(lTable, "###,##0")
            
            ' clear the script progress
            lScript = 0
            frmProgress.prgScripts.Value = 0
            frmProgress.lblScript.Caption = ""
            frmProgress.lblScriptFrom.Caption = "0"
            frmProgress.lblScriptPerc.Caption = "0 %"
            
            ' start generating the stored procs
            If (bInsert) Then
                ' generate an insert statement
                sScript = "Insert"
                GoSub UpdateScriptProgress
                GenerateInsertSQL acnCon, sTable, sType, False, bUpdateDB, bDropSP
                If bOutput Then
                    ' generate a second set of stored procs for output parameters
                    GenerateInsertSQL acnCon, sTable, sType, True, bUpdateDB, bDropSP
                End If
            End If
            If (bIdentity) Then
                ' generate an insert with identity statement
                sScript = "Identity Insert"
                GoSub UpdateScriptProgress
                GenerateInsertIdentitySQL acnCon, sTable, sType, False, bUpdateDB, bDropSP
                If bOutput Then
                    ' generate a second set of stored procs for output parameters
                    GenerateInsertIdentitySQL acnCon, sTable, sType, True, bUpdateDB, bDropSP
                End If
            End If
            If (bSelect) Then
                ' generate a select *
                sScript = "Select * "
                GoSub UpdateScriptProgress
                GenerateSelectAllSQL acnCon, sTable, sType, bUpdateDB, bDropSP
            End If
            If (bFields) Then
                ' generate a select <fields> statement
                sScript = "Select <fields>"
                GoSub UpdateScriptProgress
                GenerateSelectFieldsSQL acnCon, sTable, sType, bUpdateDB, bDropSP
            End If
            If (bUpdate) Then
                ' generate an update statement
                sScript = "Update"
                GoSub UpdateScriptProgress
                GenerateUpdateSQL acnCon, sTable, sType, bUpdateDB, bDropSP
            End If
            If (bDelete) Then
                ' generate a delete statement
                sScript = "Delete"
                GoSub UpdateScriptProgress
                GenerateDeleteSQL acnCon, sTable, sType, bUpdateDB, bDropSP
            End If
            If (bSingle) Then
                ' generate a select single record
                sScript = "Select 1"
                GoSub UpdateScriptProgress
                GenerateSelectAllSingleSQL acnCon, sTable, sType, bUpdateDB, bDropSP
                GenerateSelectFieldsSingleSQL acnCon, sTable, sType, bUpdateDB, bDropSP
            End If
            
            ' update the progress form
            iTablePercent = Fix(lTable / lTableTotal * 100)
            frmProgress.lblTablePerc.Caption = iTablePercent & " %"
            frmProgress.prgTables.Value = iTablePercent
            'frmProgress.lblScriptFrom.Caption = 0
            frmProgress.lblScriptPerc.Caption = "100 %"
            'frmProgress.lblScript = ""
            frmProgress.prgScripts.Value = 100
            DoEvents
            DoEvents
        End If
    Next lItem
    
    ' pause for 2 seconds
    g_objGlobal.Pause 2
    
    ' finished - inform the user
    sScript = "Stored Procedures have been generated."
    If Not bUpdateDB Then
        ' generating a script not updating directly
        sScript = sScript & vbCrLf & "The file created can be located at :" & vbCrLf
        sScript = sScript & "    " & m_sOutputFile
    End If
    
    Screen.MousePointer = vbDefault
    MsgBox sScript, vbInformation + vbOKOnly, g_objGlobal.sAppTitle
    DoEvents
    
    ' unload the progress form
    Unload frmProgress
    Set frmProgress = Nothing
    
    Exit Sub
'--------------------------------------------------------------------------------------------
UpdateScriptProgress:   ' update the progress for to indicate the progress
'--------------------------------------------------------------------------------------------
    lScript = lScript + 1
    iScriptPercent = Fix(lScript / lScriptTotal * 100)
    frmProgress.prgScripts.Value = iScriptPercent
    frmProgress.lblScript.Caption = sScript
    frmProgress.lblScriptFrom.Caption = lScript
    frmProgress.lblScriptPerc.Caption = iScriptPercent & " %"
    Return
End Sub
Private Sub GenerateInsertSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bOutput As Boolean, _
                                ByVal bUpdateDB As Boolean, ByVal bDropSP As Boolean)
    ' this will actually generate the SQL insert statement for this table
    Dim vntFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sFields As String
    Dim sValues As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    If bOutput Then
        ' using output parameters
        sProcName = "sp" & sTable & "InsertOutput"
    Else
        ' no output parameters
        sProcName = "sp" & sTable & "Insert"
    End If
    sDrop = sGetDropSQL(sProcName)
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sFields = ""
        sValues = ""
        
        ' process each field
        For lField = 0 To lFields
            ' add each field
            sTemp = vntFields(lField)
            sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
            sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
            If sFieldName <> sIDField Then
                ' do not insert the ID field, but insert all other fields
                arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                iProperties = UBound(arrsProperties)
                sFieldType = arrsProperties(0)
                Select Case LCase$(sFieldType)
                    Case Is = "varchar", "nvarchar"
                        sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                    Case Is = "decimal", "real", "float"
                        sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                End Select
                ' now add the parameter to the list of parameters
                If sParams = "" Then
                    ' this is the first parameter
                    sParams = "@" & sFieldName & " " & sFieldType
                Else
                    ' adding to the parameters
                    sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
                End If
                ' now add the field to the list of fields specified
                If sFields = "" Then
                    ' this is the first field
                    sFields = sFieldName
                Else
                    ' adding to the fields
                    sFields = sFields & ", " & sFieldName
                End If
                ' and now add the value to the list of values specified
                If sValues = "" Then
                    ' this is the first field
                    sValues = "@" & sFieldName
                Else
                    ' adding to the fields
                    sValues = sValues & ", @" & sFieldName
                End If
            End If
        Next lField
        
        ' check if we are returning an output parameter
        If bOutput And (sIDField <> "") Then
            ' we are - add the parameter as OUTPUT
            sParams = sParams & "," & vbCrLf & "@lOutPutVar int OUTPUT"
        End If
        
        ' now that we have all the fields we need - build the SQL statement
        sSQL = ""
        If bDropSP And Not bUpdateDB Then
            ' we need to drop the stored proc first
            sSQL = sDrop & "GO" & vbCrLf
        End If
        
        sSQL = sSQL & m_sComment & vbCrLf
        sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
        sSQL = sSQL & sParams & vbCrLf
        sSQL = sSQL & "AS" & vbCrLf
        sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
        sSQL = sSQL & "INSERT INTO " & sTable & " (" & vbCrLf
        sSQL = sSQL & sFields & ")" & vbCrLf
        sSQL = sSQL & "VALUES (" & vbCrLf
        sSQL = sSQL & sValues & ")" & vbCrLf
        sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf

        ' determine how we return the ID
        If bOutput And (sIDField <> "") Then
            ' return as output parameter
            sSQL = sSQL & "SELECT @lOutPutVar = @@IDENTITY"
        ElseIf sIDField <> "" Then
            ' no output variables - select the ID and return it
            sSQL = sSQL & "SELECT @@IDENTITY [New_ID]"
        End If
        
        ' now determine what to do with it
        If bUpdateDB Then
            ' we must update the database
            If bDropSP Then
                ' drop the SP first
                acnCon.Execute sDrop
            End If
            ' now insert the new SP
            acnCon.Execute sSQL
        Else
            ' we must output to a file
            Open m_sOutputFile For Append As #1
            Print #1, sSQL
            Print #1, "GO" & vbCrLf
            Close #1
        End If
    End If
    DoEvents
End Sub
Private Sub GenerateUpdateSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL update statement for this table
    Dim vntFields As Variant
    Dim vntKeyFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sKeyValues As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sFields As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim lKeys As Long
    Dim lKey As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim bIsKeyField As Boolean
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "Update"
    sDrop = sGetDropSQL(sProcName)
    
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        ' get the key fields
        vntKeyFields = vntGetKeyFieldsList(acnCon, sTable)
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sFields = ""
        sKeyValues = ""
        GoSub BuildKeyValues
        
        ' check if we have some sort of key or ID set
        If sKeyValues <> "" Then
            ' we do - process all the fields
            For lField = 0 To lFields
                ' add each field
                sTemp = vntFields(lField)
                sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
                sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
                ' get the field type for this field
                arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                iProperties = UBound(arrsProperties)
                sFieldType = arrsProperties(0)
                Select Case LCase$(sFieldType)
                    Case Is = "varchar", "nvarchar"
                        sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                    Case Is = "decimal", "real", "float"
                        sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                End Select
                ' add the parameter to the list of parameters
                If sParams = "" Then
                    ' this is the first parameter
                    sParams = "@" & sFieldName & " " & sFieldType
                Else
                    ' adding to the parameters
                    sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
                End If
                If sFieldName <> sIDField Then
                    ' do not update the ID field
                    ' check if this is a key field
                    GoSub CheckIfKeyField
                    ' can not update a key field either
                    If Not bIsKeyField Then
                        ' not an ID or a key fields - update it
                        arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                        iProperties = UBound(arrsProperties)
                        sFieldType = arrsProperties(0)
                        Select Case LCase$(sFieldType)
                            Case Is = "varchar", "nvarchar"
                                sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                            Case Is = "decimal", "real", "float"
                                sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                        End Select
                        ' now add the field to the list of fields specified
                        If sFields = "" Then
                            ' this is the first field
                            sFields = sFieldName & " = @" & sFieldName
                        Else
                            ' adding to the fields
                            sFields = sFields & ", " & sFieldName & " = @" & sFieldName
                        End If
                    End If
                End If
            Next lField
            
            ' now that we have all the fields we need - build the SQL statement
            sSQL = ""
            If bDropSP And Not bUpdateDB Then
                ' we need to drop the stored proc first
                sSQL = sDrop & "GO" & vbCrLf
            End If
            
            sSQL = sSQL & m_sComment & vbCrLf
            sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
            sSQL = sSQL & sParams & vbCrLf
            sSQL = sSQL & "AS" & vbCrLf
            sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
            sSQL = sSQL & "UPDATE" & vbCrLf & vbTab & sTable & vbCrLf
            sSQL = sSQL & "SET" & vbCrLf & vbTab
            sSQL = sSQL & sFields & vbCrLf
            sSQL = sSQL & "WHERE" & vbCrLf & vbTab
            sSQL = sSQL & sKeyValues & vbCrLf
            sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf
    
            ' now determine what to do with it
            If bUpdateDB Then
                ' we must update the database
                If bDropSP Then
                    ' drop the SP first
                    acnCon.Execute sDrop
                End If
                ' now insert the new SP
                acnCon.Execute sSQL
            Else
                ' we must output to a file
                Open m_sOutputFile For Append As #1
                Print #1, sSQL
                Print #1, "GO" & vbCrLf
                Close #1
            End If
        End If
    End If
    DoEvents
    Exit Sub
'--------------------------------------------------------------------------------------------
CheckIfKeyField:    ' check if sFieldName is a key field
'--------------------------------------------------------------------------------------------
    bIsKeyField = False
    ' check if we have any key fields or not
    If Not IsEmpty(vntKeyFields) Then
        ' check all the keys
        For lKey = 0 To lKeys
            ' check each key
            If vntKeyFields(lKey) = sFieldName Then
                ' is a key - set flag and exit loop
                bIsKeyField = True
                Exit For
            End If
        Next lKey
    End If
    Return
'--------------------------------------------------------------------------------------------
BuildKeyValues:     ' build the WHERE clause using the Key Values or the ID if none
'--------------------------------------------------------------------------------------------
    If Not IsEmpty(vntKeyFields) Then
        ' we have keys - use them
        lKeys = UBound(vntKeyFields) - 1
        ' add all the key fields
        For lKey = 0 To lKeys
            If sKeyValues = "" Then
                ' first key field
                sKeyValues = vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            Else
                ' adding to the key fields
                sKeyValues = sKeyValues & vbCrLf & vbTab & "AND " & vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            End If
        Next lKey
    Else
        ' no keys - check for the ID
        If sIDField <> "" Then
            ' use the ID as the value
            sKeyValues = sIDField & " = @" & sIDField
        End If
    End If
    Return
End Sub
Private Sub GenerateSelectAllSingleSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL Select for a single record statement for this table
    Dim vntFields As Variant
    Dim vntKeyFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sKeyValues As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sFields As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim lKeys As Long
    Dim lKey As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim bIsKeyField As Boolean
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "SelectAllSingle"
    sDrop = sGetDropSQL(sProcName)
    
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        ' get the key fields
        vntKeyFields = vntGetKeyFieldsList(acnCon, sTable)
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sFields = ""
        sKeyValues = ""
        GoSub BuildKeyValues
        
        ' check if we have some sort of key or ID set
        If sKeyValues <> "" Then
            ' we do - process all the fields
            For lField = 0 To lFields
                ' add each field
                sTemp = vntFields(lField)
                sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
                sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
                ' get the field type for this field
                arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                iProperties = UBound(arrsProperties)
                sFieldType = arrsProperties(0)
                Select Case LCase$(sFieldType)
                    Case Is = "varchar", "nvarchar"
                        sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                    Case Is = "decimal", "real", "float"
                        sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                End Select
                
                ' check if this is a key field
                GoSub CheckIfKeyField
                ' can not update a key field either
                If bIsKeyField Then
                    ' an ID or a key fields - use it
                    arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                    iProperties = UBound(arrsProperties)
                    sFieldType = arrsProperties(0)
                    Select Case LCase$(sFieldType)
                        Case Is = "varchar", "nvarchar"
                            sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                        Case Is = "decimal", "real", "float"
                            sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                    End Select
                    ' add the parameter to the list of parameters
                    If sParams = "" Then
                        ' this is the first parameter
                        sParams = "@" & sFieldName & " " & sFieldType
                    Else
                        ' adding to the parameters
                        sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
                    End If
                    ' now add the field to the list of fields specified
                    If sFields = "" Then
                        ' this is the first field
                        sFields = sFieldName & " = @" & sFieldName
                    Else
                        ' adding to the fields
                        sFields = sFields & ", " & sFieldName & " = @" & sFieldName
                    End If
                End If
            Next lField
            
            ' now that we have all the fields we need - build the SQL statement
            sSQL = ""
            If bDropSP And Not bUpdateDB Then
                ' we need to drop the stored proc first
                sSQL = sDrop & "GO" & vbCrLf
            End If
            
            sSQL = sSQL & m_sComment & vbCrLf
            sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
            sSQL = sSQL & sParams & vbCrLf
            sSQL = sSQL & "AS" & vbCrLf
            sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
            sSQL = sSQL & "SELECT" & vbCrLf
            sSQL = sSQL & vbTab & "*" & vbCrLf & "FROM" & vbCrLf
            sSQL = sSQL & vbTab & sTable & vbCrLf
            sSQL = sSQL & "WHERE" & vbCrLf & vbTab
            sSQL = sSQL & sKeyValues & vbCrLf
            sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf
    
            ' now determine what to do with it
            If bUpdateDB Then
                ' we must update the database
                If bDropSP Then
                    ' drop the SP first
                    acnCon.Execute sDrop
                End If
                ' now insert the new SP
                acnCon.Execute sSQL
            Else
                ' we must output to a file
                Open m_sOutputFile For Append As #1
                Print #1, sSQL
                Print #1, "GO" & vbCrLf
                Close #1
            End If
        End If
    End If
    DoEvents
    Exit Sub
'--------------------------------------------------------------------------------------------
CheckIfKeyField:    ' check if sFieldName is a key field
'--------------------------------------------------------------------------------------------
    bIsKeyField = False
    ' check if we have any key fields or not
    If Not IsEmpty(vntKeyFields) Then
        ' check all the keys
        For lKey = 0 To lKeys
            ' check each key
            If vntKeyFields(lKey) = sFieldName Then
                ' is a key - set flag and exit loop
                bIsKeyField = True
                Exit For
            End If
        Next lKey
    End If
    Return
'--------------------------------------------------------------------------------------------
BuildKeyValues:     ' build the WHERE clause using the Key Values or the ID if none
'--------------------------------------------------------------------------------------------
    If Not IsEmpty(vntKeyFields) Then
        ' we have keys - use them
        lKeys = UBound(vntKeyFields) - 1
        ' add all the key fields
        For lKey = 0 To lKeys
            If sKeyValues = "" Then
                ' first key field
                sKeyValues = vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            Else
                ' adding to the key fields
                sKeyValues = sKeyValues & vbCrLf & vbTab & "AND " & vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            End If
        Next lKey
    Else
        ' no keys - check for the ID
        If sIDField <> "" Then
            ' use the ID as the value
            sKeyValues = sIDField & " = @" & sIDField
        End If
    End If
    Return
End Sub
Private Sub GenerateSelectFieldsSingleSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL Select for a single record statement for this table
    Dim vntFields As Variant
    Dim vntKeyFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sKeyValues As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sFields As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim lKeys As Long
    Dim lKey As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim bIsKeyField As Boolean
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "SelectFieldsSingle"
    sDrop = sGetDropSQL(sProcName)
    
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        ' get the key fields
        vntKeyFields = vntGetKeyFieldsList(acnCon, sTable)
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sFields = ""
        sKeyValues = ""
        GoSub BuildKeyValues
        
        ' check if we have some sort of key or ID set
        If sKeyValues <> "" Then
            ' we do - process all the fields
            For lField = 0 To lFields
                ' add each field
                sTemp = vntFields(lField)
                sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
                sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
                ' get the field type for this field
                arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                iProperties = UBound(arrsProperties)
                sFieldType = arrsProperties(0)
                Select Case LCase$(sFieldType)
                    Case Is = "varchar", "nvarchar"
                        sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                    Case Is = "decimal", "real", "float"
                        sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                End Select
                
                ' check if this is a key field
                GoSub CheckIfKeyField
                ' can not update a key field either
                If bIsKeyField Then
                    ' an ID or a key fields - use it
                    arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                    iProperties = UBound(arrsProperties)
                    sFieldType = arrsProperties(0)
                    Select Case LCase$(sFieldType)
                        Case Is = "varchar", "nvarchar"
                            sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                        Case Is = "decimal", "real", "float"
                            sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                    End Select
                    ' add the parameter to the list of parameters
                    If sParams = "" Then
                        ' this is the first parameter
                        sParams = "@" & sFieldName & " " & sFieldType
                    Else
                        ' adding to the parameters
                        sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
                    End If
                Else
                    ' it is not a key field - check further
                    If sFieldName <> sIDField Then
                        ' not ID field either - add the field to the list of fields specified
                        If sFields = "" Then
                            ' this is the first field
                            sFields = sFieldName
                        Else
                            ' adding to the fields
                            sFields = sFields & ", " & sFieldName
                        End If
                    End If
                End If
            Next lField
            
            ' now that we have all the fields we need - build the SQL statement
            sSQL = ""
            If bDropSP And Not bUpdateDB Then
                ' we need to drop the stored proc first
                sSQL = sDrop & "GO" & vbCrLf
            End If
            
            sSQL = sSQL & m_sComment & vbCrLf
            sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
            sSQL = sSQL & sParams & vbCrLf
            sSQL = sSQL & "AS" & vbCrLf
            sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
            sSQL = sSQL & "SELECT" & vbCrLf
            sSQL = sSQL & vbTab & sFields & vbCrLf & "FROM" & vbCrLf
            sSQL = sSQL & vbTab & sTable & vbCrLf
            sSQL = sSQL & "WHERE" & vbCrLf & vbTab
            sSQL = sSQL & sKeyValues & vbCrLf
            sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf
    
            ' now determine what to do with it
            If bUpdateDB Then
                ' we must update the database
                If bDropSP Then
                    ' drop the SP first
                    acnCon.Execute sDrop
                End If
                ' now insert the new SP
                acnCon.Execute sSQL
            Else
                ' we must output to a file
                Open m_sOutputFile For Append As #1
                Print #1, sSQL
                Print #1, "GO" & vbCrLf
                Close #1
            End If
        End If
    End If
    DoEvents
    Exit Sub
'--------------------------------------------------------------------------------------------
CheckIfKeyField:    ' check if sFieldName is a key field
'--------------------------------------------------------------------------------------------
    bIsKeyField = False
    ' check if we have any key fields or not
    If Not IsEmpty(vntKeyFields) Then
        ' check all the keys
        For lKey = 0 To lKeys
            ' check each key
            If vntKeyFields(lKey) = sFieldName Then
                ' is a key - set flag and exit loop
                bIsKeyField = True
                Exit For
            End If
        Next lKey
    End If
    Return
'--------------------------------------------------------------------------------------------
BuildKeyValues:     ' build the WHERE clause using the Key Values or the ID if none
'--------------------------------------------------------------------------------------------
    If Not IsEmpty(vntKeyFields) Then
        ' we have keys - use them
        lKeys = UBound(vntKeyFields) - 1
        ' add all the key fields
        For lKey = 0 To lKeys
            If sKeyValues = "" Then
                ' first key field
                sKeyValues = vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            Else
                ' adding to the key fields
                sKeyValues = sKeyValues & vbCrLf & vbTab & "AND " & vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            End If
        Next lKey
    Else
        ' no keys - check for the ID
        If sIDField <> "" Then
            ' use the ID as the value
            sKeyValues = sIDField & " = @" & sIDField
        End If
    End If
    Return
End Sub

Private Sub GenerateDeleteSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL delete statement for this table
    Dim vntFields As Variant
    Dim vntKeyFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sKeyValues As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim lKeys As Long
    Dim lKey As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim bIsKeyField As Boolean
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "Delete"
    sDrop = sGetDropSQL(sProcName)
    
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        ' get the key fields
        vntKeyFields = vntGetKeyFieldsList(acnCon, sTable)
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sKeyValues = ""
        GoSub BuildKeyValues
        
        ' check if we have some sort of key or ID set
        If sKeyValues <> "" Then
            ' we do - process all the fields
            For lField = 0 To lFields
                ' add each field
                sTemp = vntFields(lField)
                sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
                sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
                ' get the field type for this field
                arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                iProperties = UBound(arrsProperties)
                sFieldType = arrsProperties(0)
                Select Case LCase$(sFieldType)
                    Case Is = "varchar", "nvarchar"
                        sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                    Case Is = "decimal", "real", "float"
                        sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                End Select
                ' add the parameter to the list of parameters
                If sParams = "" Then
                    ' this is the first parameter
                    sParams = "@" & sFieldName & " " & sFieldType
                Else
                    ' adding to the parameters
                    sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
                End If
                If sFieldName <> sIDField Then
                    ' do not update the ID field
                    ' check if this is a key field
                    GoSub CheckIfKeyField
                    ' can not update a key field either
                    If Not bIsKeyField Then
                        ' not an ID or a key fields - update it
                        arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
                        iProperties = UBound(arrsProperties)
                        sFieldType = arrsProperties(0)
                        Select Case LCase$(sFieldType)
                            Case Is = "varchar", "nvarchar"
                                sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                            Case Is = "decimal", "real", "float"
                                sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
                        End Select
                    End If
                End If
            Next lField
            
            ' now that we have all the fields we need - build the SQL statement
            sSQL = ""
            If bDropSP And Not bUpdateDB Then
                ' we need to drop the stored proc first
                sSQL = sDrop & "GO" & vbCrLf
            End If
            
            sSQL = sSQL & m_sComment & vbCrLf
            sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
            sSQL = sSQL & sParams & vbCrLf
            sSQL = sSQL & "AS" & vbCrLf
            sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
            sSQL = sSQL & "DELETE FROM" & vbCrLf & vbTab & sTable & vbCrLf
            sSQL = sSQL & "WHERE" & vbCrLf & vbTab
            sSQL = sSQL & sKeyValues & vbCrLf
            sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf
    
            ' now determine what to do with it
            If bUpdateDB Then
                ' we must update the database
                If bDropSP Then
                    ' drop the SP first
                    acnCon.Execute sDrop
                End If
                ' now insert the new SP
                acnCon.Execute sSQL
            Else
                ' we must output to a file
                Open m_sOutputFile For Append As #1
                Print #1, sSQL
                Print #1, "GO" & vbCrLf
                Close #1
            End If
        End If
    End If
    DoEvents
    Exit Sub
'--------------------------------------------------------------------------------------------
CheckIfKeyField:    ' check if sFieldName is a key field
'--------------------------------------------------------------------------------------------
    bIsKeyField = False
    ' check if we have any key fields or not
    If Not IsEmpty(vntKeyFields) Then
        ' check all the keys
        For lKey = 0 To lKeys
            ' check each key
            If vntKeyFields(lKey) = sFieldName Then
                ' is a key - set flag and exit loop
                bIsKeyField = True
                Exit For
            End If
        Next lKey
    End If
    Return
'--------------------------------------------------------------------------------------------
BuildKeyValues:     ' build the WHERE clause using the Key Values or the ID if none
'--------------------------------------------------------------------------------------------
    If Not IsEmpty(vntKeyFields) Then
        ' we have keys - use them
        lKeys = UBound(vntKeyFields) - 1
        ' add all the key fields
        For lKey = 0 To lKeys
            If sKeyValues = "" Then
                ' first key field
                sKeyValues = vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            Else
                ' adding to the key fields
                sKeyValues = sKeyValues & vbCrLf & vbTab & "AND " & vntKeyFields(lKey) & " = @" & vntKeyFields(lKey)
            End If
        Next lKey
    Else
        ' no keys - check for the ID
        If sIDField <> "" Then
            ' use the ID as the value
            sKeyValues = sIDField & " = @" & sIDField
        End If
    End If
    Return
End Sub

Private Sub GenerateSelectFieldsSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL Select <fields> statement for this table
    Dim vntFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sFields As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "SelectNamedFields"
    sDrop = sGetDropSQL(sProcName)
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sFields = ""
        
        ' process each field
        For lField = 0 To lFields
            ' add each field
            sTemp = vntFields(lField)
            sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
            sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
            ' now add the field to the list of fields specified
            If sFields = "" Then
                ' this is the first field
                sFields = sFieldName
            Else
                ' adding to the fields
                sFields = sFields & ", " & sFieldName
            End If
        Next lField
        
        ' now that we have all the fields we need - build the SQL statement
        sSQL = ""
        If bDropSP And Not bUpdateDB Then
            ' we need to drop the stored proc first
            sSQL = sDrop & "GO" & vbCrLf
        End If
        
        sSQL = sSQL & m_sComment & vbCrLf
        sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
        sSQL = sSQL & "AS" & vbCrLf
        sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
        sSQL = sSQL & "SELECT" & vbCrLf
        sSQL = sSQL & vbTab & sFields & vbCrLf
        sSQL = sSQL & "FROM" & vbCrLf
        sSQL = sSQL & vbTab & sTable & vbCrLf
        sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf

        ' now determine what to do with it
        If bUpdateDB Then
            ' we must update the database
            If bDropSP Then
                ' drop the SP first
                acnCon.Execute sDrop
            End If
            ' now insert the new SP
            acnCon.Execute sSQL
        Else
            ' we must output to a file
            Open m_sOutputFile For Append As #1
            Print #1, sSQL
            Print #1, "GO" & vbCrLf
            Close #1
        End If
    End If
    DoEvents
End Sub
Private Sub GenerateInsertIdentitySQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bOutput As Boolean, _
                                ByVal bUpdateDB As Boolean, ByVal bDropSP As Boolean)
    ' this will actually generate the SQL insert statement for this table using Identity
    Dim vntFields As Variant
    Dim sIDField As String
    Dim sSQL As String
    Dim sFieldName As String
    Dim sTemp As String
    Dim sProcName As String
    Dim sParams As String
    Dim sFields As String
    Dim sValues As String
    Dim sDrop As String
    Dim sFieldType As String
    Dim lFields As Long
    Dim lField As Long
    Dim iProperties As Integer
    Dim iProperty As Integer
    Dim arrsProperties() As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    If bOutput Then
        ' using output parameters
        sProcName = "sp" & sTable & "InsertIdentityOutput"
    Else
        ' no output parameters
        sProcName = "sp" & sTable & "InsertIdentity"
    End If
    sDrop = sGetDropSQL(sProcName)
    ' get the list of fields from the table
    vntFields = vntGetFieldList(acnCon, sTable)
    If Not IsEmpty(vntFields) Then
        ' get the ID field - can not insert into an ID with a normal INSERT statement
        sIDField = sGetIDField(acnCon, sTable)
        
        ' if there is no identity - do not generate any code
        If sIDField = "" Then
            ' no identity
            Exit Sub
        End If
        
        ' determine the number of fields
        lFields = UBound(vntFields) - 1
        
        ' clear some variables to be used
        sParams = ""
        sFields = ""
        sValues = ""
        
        ' process each field
        For lField = 0 To lFields
            ' add each field
            sTemp = vntFields(lField)
            sFieldName = Left$(sTemp, InStr(sTemp, ":") - 1)
            sTemp = Mid$(sTemp, InStr(sTemp, ":") + 1)
            arrsProperties = Split(sTemp, ",", -1, vbTextCompare)
            iProperties = UBound(arrsProperties)
            sFieldType = arrsProperties(0)
            Select Case LCase$(sFieldType)
                Case Is = "varchar", "nvarchar"
                    sFieldType = sFieldType & " (" & arrsProperties(1) & ")"
                Case Is = "decimal", "real", "float"
                    sFieldType = sFieldType & " (" & arrsProperties(2) & ", " & arrsProperties(3) & ")"
            End Select
            ' now add the parameter to the list of parameters
            If sParams = "" Then
                ' this is the first parameter
                sParams = "@" & sFieldName & " " & sFieldType
            Else
                ' adding to the parameters
                sParams = sParams & "," & vbCrLf & "@" & sFieldName & " " & sFieldType
            End If
            ' now add the field to the list of fields specified
            If sFields = "" Then
                ' this is the first field
                sFields = sFieldName
            Else
                ' adding to the fields
                sFields = sFields & ", " & sFieldName
            End If
            ' and now add the value to the list of values specified
            If sValues = "" Then
                ' this is the first field
                sValues = "@" & sFieldName
            Else
                ' adding to the fields
                sValues = sValues & ", @" & sFieldName
            End If
        Next lField
        
        ' check if we are returning an output parameter
        If bOutput And (sIDField <> "") Then
            ' we are - add the parameter as OUTPUT
            sParams = sParams & "," & vbCrLf & "@lOutPutVar int OUTPUT"
        End If
        
        ' now that we have all the fields we need - build the SQL statement
        sSQL = ""
        If bDropSP And Not bUpdateDB Then
            ' we need to drop the stored proc first
            sSQL = sDrop & "GO" & vbCrLf
        End If
        
        sSQL = sSQL & m_sComment & vbCrLf
        sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
        sSQL = sSQL & sParams & vbCrLf
        sSQL = sSQL & "AS" & vbCrLf
        sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
        sSQL = sSQL & "SET IDENTITY_INSERT " & sTable & " ON" & vbCrLf
        sSQL = sSQL & "INSERT INTO " & sTable & " (" & vbCrLf
        sSQL = sSQL & sFields & ")" & vbCrLf
        sSQL = sSQL & "VALUES (" & vbCrLf
        sSQL = sSQL & sValues & ")" & vbCrLf
        sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf
        sSQL = sSQL & "SET IDENTITY_INSERT " & sTable & " OFF" & vbCrLf

        ' determine how we return the ID
        If bOutput Then
            ' return as output parameter
            sSQL = sSQL & "SELECT @lOutPutVar = @@IDENTITY"
        Else
            ' no output variables - select the ID and return it
            sSQL = sSQL & "SELECT @@IDENTITY [New_ID]"
        End If
        
        ' now determine what to do with it
        If bUpdateDB Then
            ' we must update the database
            If bDropSP Then
                ' drop the SP first
                acnCon.Execute sDrop
            End If
            ' now insert the new SP
            acnCon.Execute sSQL
        Else
            ' we must output to a file
            Open m_sOutputFile For Append As #1
            Print #1, sSQL
            Print #1, "GO" & vbCrLf
            Close #1
        End If
    End If
    DoEvents
End Sub
Private Sub GenerateSelectAllSQL(acnCon As ADODB.Connection, ByVal sTable As String, _
                                ByVal sType As String, ByVal bUpdateDB As Boolean, _
                                ByVal bDropSP As Boolean)
    ' this will actually generate the SQL SELECT * statement for this table
    Dim sSQL As String
    Dim sProcName As String
    Dim sDrop As String
    Dim arsData As ADODB.Recordset
    
    ' define the SP name
    sProcName = "sp" & sTable & "SelectAllFields"
    sDrop = sGetDropSQL(sProcName)
        
    ' build the SQL statement
    sSQL = ""
    If bDropSP And Not bUpdateDB Then
        ' we need to drop the stored proc first
        sSQL = sDrop & "GO" & vbCrLf
    End If
    
    sSQL = sSQL & m_sComment & vbCrLf
    sSQL = sSQL & "CREATE PROCEDURE " & sProcName & vbCrLf
    sSQL = sSQL & "AS" & vbCrLf
    sSQL = sSQL & "SET NOCOUNT ON" & vbCrLf
    sSQL = sSQL & "SELECT * FROM " & sTable & vbCrLf
    sSQL = sSQL & "SET NOCOUNT OFF" & vbCrLf

    ' now determine what to do with it
    If bUpdateDB Then
        ' we must update the database
        If bDropSP Then
            ' drop the SP first
            acnCon.Execute sDrop
        End If
        ' now insert the new SP
        acnCon.Execute sSQL
    Else
        ' we must output to a file
        Open m_sOutputFile For Append As #1
        Print #1, sSQL
        Print #1, "GO" & vbCrLf
        Close #1
    End If
    DoEvents
End Sub
Private Function sGetDropSQL(ByVal sProcName As String) As String
    ' this function will generate a DROP SQL syntax for sProcName
    Dim sTemp As String
     
    sTemp = "if exists (select * from sysobjects where id = object_id(N'[dbo].["
    sTemp = sTemp & sProcName
    sTemp = sTemp & "]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)" & vbCrLf
    sTemp = sTemp & vbTab & "drop procedure [dbo].[" & sProcName & "]" & vbCrLf
    'sTemp = sTemp & "GO" & vbCrLf
    sGetDropSQL = sTemp
End Function


Public Sub ShowSplashScreen()
    frmSplash.p_bOK = False
    frmSplash.Show vbModal
    Set frmSplash = Nothing
End Sub
Private Function sSQLDataType(ByVal lType As Long) As String
    ' this will convert from ADO data types to the textual version used by SQL
    Dim sReturn As String
    ' determine what the result is
    Select Case lType
        'Case adEmpty
        '    sReturn = ""
        'Case adTinyInt
        '    sReturn = ""
        Case adSmallInt
            sReturn = "smallint"
        Case adInteger
            sReturn = "int"
        Case adBigInt
            sReturn = "bigint"
        Case adUnsignedTinyInt
            sReturn = "tinyint"
        'Case adUnsignedSmallInt
        '    sReturn = ""
        'Case adUnsignedInt
        '    sReturn = ""
        'Case adUnsignedBigInt
        '    sReturn = ""
        Case adSingle
            sReturn = "real"
        Case adDouble
            sReturn = "float"
        Case adCurrency
            sReturn = "money"
        'Case adDecimal
        '    sReturn = ""
        Case adNumeric
            sReturn = "decimal"
        Case adBoolean
            sReturn = "bit"
        'Case adError
        '    sReturn = ""
        'Case adUserDefined
        '    sReturn = ""
        'Case adVariant
        '    sReturn = "sql_variant"
        'Case adIDispatch
        '    sReturn = ""
        'Case adIUnknown
        '    sReturn = ""
        Case adGUID
            sReturn = "uniqueidentifier"
        'Case adDate
        '    sReturn = ""
        'Case adDBDate
        '    sReturn = ""
        'Case adDBTime
        '    sReturn = ""
        Case adDBTimeStamp
            sReturn = "datetime"
        'Case adBSTR
        '    sReturn = ""
        Case adChar
            sReturn = "varchar"
        Case adVarChar
            sReturn = "varchar"
        Case adLongVarChar
            sReturn = "text"
        Case adWChar
            sReturn = "nchar"
        Case adVarWChar
            sReturn = "nvarchar"
        Case adLongVarWChar
            sReturn = "ntext"
        Case adBinary
            sReturn = "binary"
        Case adVarBinary
            sReturn = "image"
        'Case adLongVarBinary
        '    sReturn = ""
        Case Else
            ' some other / unknown type
            sReturn = "UNKNOWN !!!"
    End Select
    ' return the result
    sSQLDataType = sReturn
End Function
Public Sub WhenFormIsLoaded(frm As Form)
    g_objGlobal.CenterForm frm
    g_objGlobal.RemoveSystemClose frm
End Sub
Private Function vntGetKeyFieldsList(acnCon As ADODB.Connection, ByVal sTableName As String) As Variant
    ' retrieve the list of fields that make up the KEY (primary) for this table / view
    Dim sFields As String
    Dim arrsFields() As String
    Dim arsData As ADODB.Recordset
    
    ' open the schema for the table
    Set arsData = acnCon.OpenSchema(adSchemaPrimaryKeys, Array(Empty, Empty, sTableName))
    If arsData.EOF And arsData.BOF Then
        ' there was an error retrieving the information - no columns in the table
        vntGetKeyFieldsList = Empty
    Else
        ' we have columns - proceed from here
        sFields = ""
        ' get all the fields from the recordset
        Do While Not arsData.EOF
            ' get each of the fields
            sFields = sFields & arsData("Column_Name") & "|"
            arsData.MoveNext
        Loop
        arrsFields = Split(sFields, "|", , vbTextCompare)
        vntGetKeyFieldsList = arrsFields()
    End If
    
    ' clean up
    If Not (arsData Is Nothing) Then
        If arsData.State = adStateOpen Then
            arsData.Close
        End If
        Set arsData = Nothing
    End If
End Function
Private Function sGetIDField(acnCon As ADODB.Connection, ByVal sTableName As String) As String
    ' retrieve the nameo f the ID field (Auto-Increment) if any
    Dim arsData As ADODB.Recordset
    Dim afdField As ADODB.Field
    
    ' open the schema for the table
    Set arsData = New ADODB.Recordset
    arsData.Open sTableName, acnCon, adOpenDynamic, adLockReadOnly, adCmdTable
    
    ' default return value
    sGetIDField = ""
    
    If Not (arsData.EOF And arsData.BOF) Then
        ' we have columns - proceed from here
        ' get all the fields from the recordset
        For Each afdField In arsData.Fields
            ' check each field
            If afdField.Properties("ISAUTOINCREMENT") = True Then
                ' this is the ID field
                sGetIDField = afdField.Name
                Exit For
            End If
        Next
        Set afdField = Nothing
    End If
    
    ' clean up
    If Not (arsData Is Nothing) Then
        If arsData.State = adStateOpen Then
            arsData.Close
        End If
        Set arsData = Nothing
    End If
End Function
Private Function vntGetFieldList(acnCon As ADODB.Connection, ByVal sTableName As String) As Variant
    ' retrieve the list of fields for the table/ view
    Dim sFields As String
    Dim sDataType As String
    Dim arrsFields() As String
    Dim lFieldType As Long
    Dim lMaxLength As Long
    Dim arsData As ADODB.Recordset
    
    ' open the schema for the table
    Set arsData = acnCon.OpenSchema(adSchemaColumns, Array(Empty, Empty, sTableName, Empty))
    If arsData.EOF And arsData.BOF Then
        ' there was an error retrieving the information - no columns in the table
        vntGetFieldList = Empty
    Else
        ' we have columns - proceed from here
        sFields = ""
        ' get all the fields from the recordset
        Do While Not arsData.EOF
            ' get each of the fields
            sFields = sFields & arsData("Column_Name")
            lFieldType = arsData("Data_Type")
            sDataType = sSQLDataType(lFieldType)
            lMaxLength = Val(Format$(arsData("Character_Maximum_Length"), "@;"))
            ' check for TEXT or IMAGE data types
            If sDataType = "varchar" And lMaxLength = 2147483647 Then
                lMaxLength = 16
                sDataType = "text"
            ElseIf sDataType = "binary" And lMaxLength = 2147483647 Then
                lMaxLength = 16
                sDataType = "image"
            End If
            sFields = sFields & ":" & sDataType
            sFields = sFields & "," & lMaxLength
            sFields = sFields & "," & Val(Format$(arsData("Numeric_Precision"), "@;"))
            sFields = sFields & "," & Val(Format$(arsData("Numeric_Scale"), "@;"))
            sFields = sFields & "|"
            arsData.MoveNext
        Loop
        ' now convert to an array
        arrsFields() = Split(sFields, "|", , vbTextCompare)
        vntGetFieldList = arrsFields()
        Erase arrsFields
    End If
    
    ' clean up
    If Not (arsData Is Nothing) Then
        If arsData.State = adStateOpen Then
            arsData.Close
        End If
        Set arsData = Nothing
    End If
End Function
